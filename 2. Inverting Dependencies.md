# 2. Inverting Dependencies

## The Single Responsibility Principle  

A common interpretation of this principle is this:
> A component should do only one thing, and do it right.  

Here‚Äôs the actual definition of the SRP:
> A component should have only one reason to change.  

As we see, ‚Äúresponsibility‚Äù should actually be translated to ‚Äúreason to change‚Äù instead of ‚Äúdo only one thing‚Äù. Perhaps we should rename the SRP to ‚ÄúSingle Reason to Change Principle‚Äù.  

If a component has only one reason to change, we don‚Äôt have to worry about this component at all
if we change the software for any other reason, because we know that it will still work as expected.  

Sadly, it‚Äôs very easy for a reason to change to propagate through code via the dependencies of a
component to other components.  

![figure006](./images/figure006.png)  

The only reason to change component E is when the functionality of E must change due to some new requirement. Component A, however, possibly might have to change when any of the other components change, because it depends on them.  

## The Dependency Inversion Principle  

In contrast to the SRP, the Dependency Inversion Principle (DIP) means what the name suggests:  

> We can turn around (invert) the direction of any dependency within our codebase.  

## Clean Architecture  ‚¨ÖÔ∏è

The layers in this architecture are wrapped around each other in concentric circles. The main rule in such an architecture is the Dependency Rule, which states that all dependencies between those layers must point inward.

![figure008](./images/figure008.png)  

The core of the architecture contains the domain entities which are accessed by the surrounding use cases. The use cases are what we have called services earlier, but are more fine-grained to have a single responsibility (i.e. a single reason to change), thus avoiding the problem of broad services we have discussed earlier.  

Around this core we can find all the other components of our application that support the business rules. This support can mean providing persistence or providing a user interface, for example. Also, the outer layers may provide adapters to any other third-party component.  

Since the domain code knows nothing about which persistence or UI framework is used, it cannot contain any code specific to those frameworks and will concentrate on the business rules. 

Clean Architecture comes at a cost, we have to maintain a model of our application‚Äôs entities in each of the layers.

## Hexagonal Architecture (‚ö†Ô∏è improve this part, summary is üí©)

![figure009](./images/figure009.png)  

Within the hexagon, we find our domain entities and the use cases that work with them.  

Outside of the hexagon, we find various adapters that interact with the application. There might be a web adapter that interacts with a web browser, so on an so forth.  

|          Left Adapters         	|              Right Adapters             	|
|:------------------------------:	|:---------------------------------------:	|
| They call our application core 	| They are called by our application core 	|  

